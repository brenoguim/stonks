<!DOCTYPE html>
<html>
<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.9.4/Chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js/dist/chart.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>

<style>
table, td {
  border: 1px solid black;
}
</style>

<head>
<title>Stonks</title>
<meta charset="utf-8" />
</head>

<body>

<h1>Stonks</h1>

Use os dados de movimentações extraídos da B3 para calcular os impostos a pagar em todos os meses.
Os dados não são armazenados - todos os calculos são executados no seu proprio browser e nenhum dado é compartilhado.

<h2>Obtendo dados da B3</h2>
<ol>
<li>Vá ao <a href="https://www.investidor.b3.com.br">site da B3</a> na seção de Extrato > Negociação.</li>
<li>Clique em "Filtrar" e coloque a data inicial "01/01/XXXX" e data final "30/12/XXXX" onde XXXX é o ano que você fez a primeira movimentação.</li>
<li>Clique em "Baixar extrato" e selecione a opção de "Arquivo em Excel"</li>
<li>Repita o processo para coletar as negociações de todos os anos até hoje</li>
<li>Clique ao lado e importe todos os arquivos de negociação de uma só vez: <input type="file" name="inputfile" accept=".xlsx	" id="inputfile" multiple/>
</ol>

<h2>Tabela de vendas e lucro por mês com cálculo de imposto a ser pago</h2>

<table id="TabelaDeVendasGlobal">
<thead>
    <tr>
    <td>Ano/Mes</td>
    <td>Vendas no mês</td>
    <td>Lucro no mês</td>
    <td>Lucro acumulado</td>
    <td>Imposto</td>
    <td>Imposto deduzido de prejuízo</td>
    </tr>
</thead>
</table>

<br><br>
<h2>Carteira</h2>
<br>
Usamos um proxy server para conseguir acessar dados do Yahoo Finance. Para habilitar o proxy <a href="https://cors-anywhere.herokuapp.com/" target="_blank" rel="noopener noreferrer">entre aqui</a> e clique para autorizar.
Vai demorar apenas 2 segundos :)
<br><br>
Agora que voce fez isso, clique aqui para calcular a rentabilidade:
<input id="clickMe" type="button" value="Baixar dados de mercado e calcular rentabilidade" onclick="calculateProfit();"/>
<br><br>

<table id="TabelaDeCarteira">
<thead>
    <tr>
    <td>Ação</td>
    <td>Quantidade</td>
    <td>Preço médio</td>
    <td>Valor de aquisição</td>
    <td>Valor de mercado</td>
    <td>Rentabilidade</td>
    <td>Lucro/Prejuízo</td>
    </tr>
</thead>
</table>

<br><br>
<h2>Gráfico de Lucro/Prejuízo ao longo do tempo</h2>
<canvas id="myChart" style="width:100%;max-width:1800px"></canvas>

</body>
</html>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.13.5/xlsx.full.min.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.13.5/jszip.js"></script>

<script>
let realBRLocale = Intl.NumberFormat("pt-BR", {
    style: "currency",
    currency: "BRL",
});

function asCurrency(value) {
    return realBRLocale.format(value)
}

function asPercentage(value) {
    return (100.0*value).toFixed(2) + "%"
}

function getMonth(date) {
    return new Date(date.getFullYear(), date.getMonth()+1, 0);
}

function parseCurrency(value) {
    return parseFloat(value.replace(/,/, '.').replace(/[.](?=.*[.])/g, ""))
}

function arrLast(arr) { return arr[arr.length - 1]; }

function parseDate(date) {
    // Expect DD/MM/YYYY
    var parts = date.split("/")
    return new Date(parseInt(parts[2]),
                    parseInt(parts[1]),
                    parseInt(parts[0]))
}

var s_originalOps = [];
var s_opsPerMonth = [];
var s_wallet = [];
var s_stockPrices = {};

function updateTable() {
    var table = document.getElementById("TabelaDeVendasGlobal");
    
    while (table.rows.length > 1) {
        table.deleteRow(-1);
    }

    for (let m = 0; m < s_opsPerMonth.length; m++) {
        var mo = s_opsPerMonth[m];
        var r = table.insertRow(-1);
        r.insertCell(-1).innerHTML = mo.date.toLocaleDateString();
        r.insertCell(-1).innerHTML = asCurrency(mo.sold);
        r.insertCell(-1).innerHTML = asCurrency(mo.profit);
        r.insertCell(-1).innerHTML = asCurrency(mo.accProfit);
        r.insertCell(-1).innerHTML = asCurrency(mo.taxOnGain);
        r.insertCell(-1).innerHTML = asCurrency(mo.lossDeducedTaxOnGain);
    }
}

function updateWalletTable() {
    var table = document.getElementById("TabelaDeCarteira");
    
    while (table.rows.length > 1) {
        table.deleteRow(-1);
    }

    var totalProfit = 0
    var totalAcquirePrice = 0;
    var totalMktPrice = 0

    for (let i = 0; i < s_wallet.length; i++) {
        var s = s_wallet[i];
        var r = table.insertRow(-1);
        r.insertCell(-1).innerHTML = s.ticker;
        r.insertCell(-1).innerHTML = s.ownedStocks;
        r.insertCell(-1).innerHTML = asCurrency(s.avgPrice);
        r.insertCell(-1).innerHTML = asCurrency(s.ownedStocks * s.avgPrice);

        totalAcquirePrice += s.ownedStocks * s.avgPrice;

        var mktPrice = (s.ticker in s_stockPrices) ? arrLast(s_stockPrices[s.ticker].prices)[1] : 0;
        totalMktPrice += mktPrice * s.ownedStocks;

        r.insertCell(-1).innerHTML = mktPrice != 0 ? asCurrency(mktPrice) : "-";
        r.insertCell(-1).innerHTML = mktPrice != 0 ? asPercentage(mktPrice / s.avgPrice - 1) : "-";
        r.insertCell(-1).innerHTML = mktPrice != 0 ? asCurrency(s.ownedStocks * (mktPrice - s.avgPrice)) : "-";
        totalProfit += mktPrice != 0 ? (s.ownedStocks * (mktPrice - s.avgPrice)) : 0;
    }

    var r = table.insertRow(-1);
    r.insertCell(-1).innerHTML = "Total"
    r.insertCell(-1).innerHTML = "";
    r.insertCell(-1).innerHTML = "";
    r.insertCell(-1).innerHTML = asCurrency(totalAcquirePrice);
    r.insertCell(-1).innerHTML = totalProfit != 0 ? asCurrency(totalMktPrice) : "-";
    r.insertCell(-1).innerHTML = totalProfit != 0 ? asPercentage(totalMktPrice / totalAcquirePrice - 1) : "-";
    r.insertCell(-1).innerHTML = totalProfit != 0 ? asCurrency(totalProfit) : "-";
}

function differentMonth(d1, d2) {
    return d1.getMonth() != d2.getMonth() || d1.getFullYear() != d2.getFullYear();
}

function processOps(ops) {
        ops = structuredClone(ops);

        for (let i = 0; i < ops.length; i++) {
            ops[i].date = parseDate(ops[i]["Data do Negócio"]);
            ops[i].ticker = ops[i]["Código de Negociação"];
            ops[i].sell = ops[i]["Tipo de Movimentação"] == "Venda";
            ops[i].numStocks = parseInt(ops[i]["Quantidade"]);
            ops[i].unitPrice = parseCurrency(ops[i]["Preço"]);
        }

        ops.sort(function(e1, e2) {
            return e1.date < e2.date ? -1 : 1;
        });

        // Calculate num stocks + avg buy price
        var numStocks = {};
        var avgPrice = {};
        for (let i = 0; i < ops.length; i++) {
            var o = ops[i];
            if (!(o.ticker in numStocks)) { numStocks[o.ticker] = 0; avgPrice[o.ticker] = 0; }

            if (o.sell) {
                numStocks[o.ticker] -= o.numStocks;
                o.ownedStocks = numStocks[o.ticker];
                o.profit = (o.unitPrice -  avgPrice[o.ticker]) * o.numStocks;
            } else {
                var prevMktValue = avgPrice[o.ticker] * numStocks[o.ticker];

                numStocks[o.ticker] += o.numStocks;
                o.ownedStocks = numStocks[o.ticker];

                var newMktValue = prevMktValue + o.numStocks * o.unitPrice;

                avgPrice[o.ticker] = newMktValue / o.ownedStocks;
            }

            o.avgPrice = avgPrice[o.ticker];
        }

        // Separate in operations per month
        var opsPerMonth = [];
        var lastDate = new Date;
        for (let i = 0; i < ops.length; i++) {
            var m = getMonth(ops[i].date);
            if (differentMonth(m, lastDate)) {
                opsPerMonth.push({'date': m, 'ops' : []});
            }
            lastDate = m;
            opsPerMonth[opsPerMonth.length-1].ops.push(ops[i]);
        }

        // Calculate sold amount
        var accProfit = 0;
        for (let m = 0; m < opsPerMonth.length; m++) {
            var mops = opsPerMonth[m].ops;
            var sold = 0;
            var profit = 0;
            for (let i = 0; i < mops.length; i++) {
                var o = mops[i];
                if (o.sell) {
                    sold += o.unitPrice * o.numStocks;
                    profit += o.profit;
                }
            }
            accProfit += profit;
            opsPerMonth[m].sold = sold;
            opsPerMonth[m].profit = profit;

            var taxOnGain = profit > 0 && sold > 20000 ? 0.15*profit : 0;
            opsPerMonth[m].taxOnGain = taxOnGain;
            
            // If made a bit of profit, but I'm on overall losses, deduce the taxes
            //     I would have to pay from overall losses
            if (taxOnGain > 0 && accProfit < 0) {
                var losses = -accProfit;
                if (losses >= taxOnGain) {
                    losses -= taxOnGain;
                    taxOnGain = 0;
                } else {
                    taxOnGain -= losses;
                    losses = 0;
                }
                accProfit = -losses;
            }

            opsPerMonth[m].lossDeducedTaxOnGain = taxOnGain;
            opsPerMonth[m].accProfit = accProfit;
        }
        return opsPerMonth;
}

function calculateWallet() {
    var lastOps = {};
    for (let m = 0; m < s_opsPerMonth.length; m++) {
        var mops = s_opsPerMonth[m].ops;
        for (let i = 0; i < mops.length; i++) {
            lastOps[mops[i].ticker] = mops[i];
        }            
    }

    var wallet = [];
    for (const [ticker, lastOp] of Object.entries(lastOps)) {
        if (lastOp.ownedStocks > 0) {
            wallet.push({ 'ticker' : ticker, 'ownedStocks' : lastOp.ownedStocks, 'avgPrice' : lastOp.avgPrice });
        }
    }

    wallet.sort(function(a,b) { return a.ticker < b.ticker ? -1 : 1; });

    return wallet;
}



function readFile(file) {
    var fr = new FileReader();
    fr.onload = function(e) {
        var workbook = XLSX.read(e.target.result, {type: 'binary'});
        var Sheet = workbook.SheetNames[0];
        var excelRows = XLSX.utils.sheet_to_row_object_array(workbook.Sheets[Sheet]);

        s_originalOps = s_originalOps.concat(excelRows);
        s_opsPerMonth = processOps(s_originalOps);

        s_wallet = calculateWallet();
        updateTable();
        updateWalletTable();
    };
    fr.readAsBinaryString(file);
}

async function getStockPrices(stock) {
    if (stock in s_stockPrices) { return; }

    const cors_url = "https://cors-anywhere.herokuapp.com/";
    const yahoo_url = "https://query1.finance.yahoo.com/v8/finance/chart/"
    const config = "?metrics=low&interval=1d&range=5y&events=div";

    var stockSym = stock + ".SA";
    if (stock == "TIMP3") { stockSym = "TIMS3.SA"; }
    if (stock == "TIMP3F") { stockSym = "TIMS3F.SA"; }

    let url = cors_url + yahoo_url + stockSym + config;
    const response = await fetch(url);

    if (response.status != 200) {
        console.log("Failed to get information for: " + stock);
        return;
    }

    const json = await response.json();
    const timestamps = json.chart.result[0].timestamp;
    const closingValues = json.chart.result[0].indicators.quote[0].close;

    var dividends = null;
    if ("events" in json.chart.result[0]) {
        dividends = json.chart.result[0].events.dividends;
    }

    var prices = [];
    for (let i = 0; i < timestamps.length; i++) {
        prices.push([new Date(timestamps[i]*1000), closingValues[i], timestamps[i]]);
    }

    console.log("Got price data for: " + stock);
    s_stockPrices[stock] = { "prices" : prices, "dividends" : dividends };
}

function getOpAtDate(ticker, date) {
    var lastOp = null;
    for (let m = 0; m < s_opsPerMonth.length; m++) {
        var mops = s_opsPerMonth[m].ops;
        for (let i = 0; i < mops.length; i++) {
            var op = mops[i];
            if (date < op.date) { return lastOp; }
            if (ticker == op.ticker) { lastOp = [m, i]; }
        }
    }
    return lastOp;
}

function updateWalletHistory () {
    var wh = [];
    for (const [ticker, data] of Object.entries(s_stockPrices)) {
        var prices = data.prices;
        if (prices.length >= 1244) { // hack! I can't get the full history from some stocks. Ignore them completely.
            wh = prices.map(function (val) { return [val[0], 0]; });
            break;
        }
    }
    if (wh.length == 0) {
        console.log("Failed to find reference of dates");
        updateWalletTable();
        return;
    }

    console.log("Rebuilding wallet");

    for (const [ticker, data] of Object.entries(s_stockPrices)) {
        var prices = data.prices;
        if (prices.length != wh.length) { continue; }

        var accDiv = 0;
        for (let i = 0; i < wh.length; i++) {
            var d = wh[i][0];    
            const mi = getOpAtDate(ticker, d);
            if (mi != null) {
                const op = s_opsPerMonth[mi[0]].ops[mi[1]];

                if (data.dividends && prices[i][2] in data.dividends) {
                    accDiv += data.dividends[prices[i][2]].amount * op.ownedStocks;
                }

                wh[i][1] += (prices[i][1] - op.avgPrice)*op.ownedStocks + accDiv;
            }
        }
    }

    var idx = wh.findIndex( function(v) { return v[1] != 0; } );
    wh = wh.slice(idx);

    var xValues = wh.map(function(v) { return v[0]; });
    var yValues = wh.map(function(v) { return v[1]; });

    const opts = {
      scales: {
        xAxes: {
          type: 'time',
            time: {
        	unit: 'day',
            unitStepSize: 1,
            displayFormats: {
          	  'millisecond': 'MMM dd',
              'second': 'MMM dd',
              'minute': 'MMM dd',
              'hour': 'MMM dd',
              'day': 'MMM dd',
              'week': 'MMM dd',
              'month': 'MMM dd',
              'quarter': 'MMM dd',
              'year': 'MMM dd',
            }
          }
        },
      },
    };

    let chartStatus = Chart.getChart("myChart"); // <canvas> id
    if (chartStatus != undefined) {
      chartStatus.destroy();
    }
    new Chart("myChart", {
      type: "line",
      data: {
        labels: xValues,
        datasets: [{
          label: "Lucro/Prejuízo",
          pointRadius: 3,
          fill: false,
          lineTension: 0,
          backgroundColor: "rgba(0,0,255,1.0)",
          borderColor: "rgba(0,0,255,0.5)",
          data: yValues
        }]
      },
      options : opts,
    });

    //console.log(wh);
    updateWalletTable();
}

function calculateProfit() {
    var requestedStocks = {};
    for (let m = 0; m < s_opsPerMonth.length; m++) {
        var mops = s_opsPerMonth[m].ops;
        for (let i = 0; i < mops.length; i++) {
            var ticker = mops[i].ticker;
            if (!(ticker in requestedStocks)) {
                requestedStocks[ticker] = 1;
                getStockPrices(ticker).then(updateWalletHistory);
            }
        }
    }
}

document.getElementById('inputfile')
    .addEventListener('change', function() {
        s_originalOps = [];
        for (let i = 0; i < this.files.length; i++) {
            readFile(this.files[i]);
        }
    })
  
</script>
